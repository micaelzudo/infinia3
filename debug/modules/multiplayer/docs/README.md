# Multiplayer Module (SpacetimeDB Integration)

This module contains the client-side TypeScript code for integrating multiplayer functionality using SpacetimeDB.

## Files

-   `spacetimeConfig.ts`: Handles connection logic to the SpacetimeDB instance, including setting up the `DbConnection` and re-exporting generated types and reducers.
-   `playerState.ts`: (Legacy) Defines older types for player state. Prefer types from the `generated` folder for new development.
-   `networkEvents.ts`: (Legacy) Defines a custom event emitter for SpacetimeDB table updates. Prefer direct usage of table subscriptions and generated types/reducers for new development.
-   `index.ts`: Barrel file, re-exporting key components from this module, including generated bindings.
-   `example.ts`: Provides a practical example of how to connect to SpacetimeDB, register players, send updates, and subscribe to table changes using a `MultiplayerManager` class structure.
-   `generated/`: This directory contains TypeScript bindings (tables, types, reducers) automatically generated by the SpacetimeDB CLI from your Rust server module. These should be the primary way to interact with SpacetimeDB on the client.

## SpacetimeDB Server-Side Setup (Rust Module)

This client-side code expects a corresponding SpacetimeDB Rust module running on the server. You will need to:

1.  **Install SpacetimeDB CLI and Rust:**
    Follow the official SpacetimeDB documentation: [https://spacetimedb.com/docs/getting-started/installation](https://spacetimedb.com/docs/getting-started/installation)

2.  **Create a SpacetimeDB Rust Project:**
    Use the SpacetimeDB CLI to create a new Rust module project.
    ```bash
    spacetimedb new my_game_module
    cd my_game_module
    ```

3.  **Define Tables and Reducers in `src/lib.rs`:**
    The server module (`debug/modules/multiplayer/server/src/lib.rs`) defines the core database schema and logic. Key components include:

    *   **Tables:**
        *   `PlayerData`: Stores active player information (ID, username, position, rotation, health, mana, input state, etc.).
        *   `LoggedOutPlayerData`: Persists essential player data when they disconnect (ID, username, last known position/rotation, health, mana).
        *   `GameTickSchedule`: Manages the game tick timing.
        *   `TerrainChunk`: Stores terrain data for different planets and chunk coordinates.
    *   **Reducers (Server-Side Functions):**
        *   `init()`: Initializes the game state, typically setting up the `GameTickSchedule`.
        *   `identity_connected(ctx, user_agent)`: Handles new client connections. Currently logs the connection.
        *   `identity_disconnected(ctx)`: Handles client disconnections. It moves player data from `PlayerData` to `LoggedOutPlayerData` and cleans up their active `PlayerData` entry.
        *   `register_player(ctx, username)`: Registers a new player or logs in an existing one. It checks `LoggedOutPlayerData` for existing users and then creates/updates `PlayerData`.
        *   `update_player_input(ctx, input)`: Receives `InputState` from the client and updates the corresponding `PlayerData` entry.
        *   `game_tick(ctx)`: Executed periodically based on `GameTickSchedule`. It iterates through `PlayerData` to apply game logic like movement (based on `InputState`), health/mana regeneration, and potentially other server-authoritative updates. It uses helper functions from `player_logic.rs`.
        *   `store_terrain_chunk(ctx, planet_id, chunk_coord_x, chunk_coord_y, chunk_coord_z, voxel_data)`: Stores or updates a `TerrainChunk`.
        *   `get_terrain_chunk(ctx, planet_id, chunk_coord_x, chunk_coord_y, chunk_coord_z)`: (Server-side) Retrieves a `TerrainChunk`. Note: Client-side terrain retrieval is typically handled by subscribing to the `TerrainChunk` table.
        *   `store_initial_chunks_for_planet(ctx, planet_id, chunks)`: Stores a batch of initial terrain chunks for a new planet.
    *   **Helper Modules:**
        *   `common.rs`: Defines shared data structures like `Vector3`, `InputState`, and game constants.
        *   `player_logic.rs`: Contains functions for player movement calculation, position validation, and other player-specific game logic used by `game_tick` and `update_player_input`.

    For the exact structure and implementation, refer to `debug/modules/multiplayer/server/src/lib.rs`, `debug/modules/multiplayer/server/src/common.rs`, and `debug/modules/multiplayer/server/src/player_logic.rs`.

4.  **Build and Run the SpacetimeDB Module:**
    ```bash
    spacetimedb build
    spacetimedb run
    ```
    Note the URL and database name output by `spacetimedb run`. You'll need these for `spacetimeConfig.ts`.

5.  **Generate TypeScript Client Bindings:**
    After building your Rust module, generate the TypeScript client SDK bindings:
    ```bash
    # From your Rust module directory (e.g., my_game_module)
    spacetimedb generate --lang typescript --out ../your_typescript_project/src/generated_spacetimedb # Adjust path as needed
    ```
    This will create files like `player_state.ts`, `update_player_state_reducer.ts`, etc., in the output directory. You will import these generated files in your main game code (e.g., `isolatedThirdPerson.ts`) to interact with SpacetimeDB.

## Client-Side Integration Steps (in your game code, e.g., `isolatedThirdPerson.ts`)

1.  **Install SpacetimeDB TypeScript SDK:**
    ```bash
    npm install @clockworklabs/spacetimedb-sdk
    # or
    yarn add @clockworklabs/spacetimedb-sdk
    # or
    pnpm add @clockworklabs/spacetimedb-sdk
    ```

2.  **Import and Use Generated Bindings:**
    -   Import `connect` and other necessary functions/types from `./multiplayer/spacetimeConfig.ts` (which re-exports from `./generated/` and provides connection utilities).
    -   Import generated table classes (e.g., `PlayerData`, `TerrainChunk`) and reducer functions (e.g., `RegisterPlayerReducer`, `UpdatePlayerInputReducer`, `StoreTerrainChunkReducer`) from the `generated/` folder (or via `spacetimeConfig.ts`).
    -   Call `connect()` (from `spacetimeConfig.ts`) to establish a connection to the SpacetimeDB server.
    -   Once connected (the promise from `connect()` resolves), you can register your client-side reducers (if any, though most logic is server-side) and subscribe to table updates using the `clientDB` instance from the connection.
    -   Use the generated reducer functions to send data to the server (e.g., `RegisterPlayerReducer.call(username)` or `UpdatePlayerInputReducer.call(inputState)`).
    -   Subscribe to table updates (e.g., `PlayerData.onInsert((playerData, reducerEvent) => { ... })`, `PlayerData.onUpdate(...)`, `PlayerData.onDelete(...)`) to react to changes in game state and update your local game world (e.g., creating, moving, or removing remote player representations).
    -   The `example.ts` file provides a `MultiplayerManager` class that demonstrates a structured way to handle these connections, subscriptions, and reducer calls. It's a good reference for your own integration.

## Important Notes

-   Ensure the `SPACETIMEDB_URL`, `DATABASE_NAME`, and `MODULE_NAME` constants in `spacetimeConfig.ts` (or your environment variables if using them) match your SpacetimeDB server setup.
-   **Always prefer using the TypeScript bindings generated by SpacetimeDB CLI** (from the `generated/` folder) for interacting with tables and reducers. The `spacetimeConfig.ts` file re-exports these for convenience.
-   The client-side code in this module provides the core logic for SpacetimeDB communication. You will need to integrate this with your game's rendering and input systems (e.g., in `isolatedThirdPerson.ts` or your main game loop) to handle player representation, input processing, and world updates.
-   For UI integration examples, such as connecting the multiplayer system to React components or using hooks for player state and connection status, refer to the `SETUP_GUIDE.md` file and the `debug/modules/ui/multiplayer/` directory.
-   Advanced features like client-side prediction, server reconciliation, and sophisticated lag compensation are not part of this foundational module and would require further implementation based on specific game needs.